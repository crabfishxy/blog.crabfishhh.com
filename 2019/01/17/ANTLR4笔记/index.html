<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ANTLR4笔记 | CrabFish's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ANTLR4笔记</h1><a id="logo" href="/.">CrabFish's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ANTLR4笔记</h1><div class="post-meta">Jan 17, 2019<span> | </span><span class="category"><a href="/categories/技术备忘/">技术备忘</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/01/17/ANTLR4笔记/" href="/2019/01/17/ANTLR4笔记/#disqus_thread"></a><div class="post-content"><p>最近毕业设计有涉及到部分编译原理的内容，又要接触到词法、文法这些东西，因为是基于Java平台，就发现了ANTLR4这个非常好用的工具。其实它不仅可以生成Java目标代码，C++, Python都是可以的。非常后悔没有在上程序设计方法学和编译原理课程时发现它。</p>
<h2 id="简介及安装"><a href="#简介及安装" class="headerlink" title="简介及安装"></a>简介及安装</h2><p>ANTLR4是一个非常强大的词法和语法生成器，采用递归下降的策略，和C的Bison和yacc的功能相似，也就是编译原理中学到的前端，但它相比其他前端是一个非常现代化的工具，这一点还是非常重要的，网上有丰富的资源可以来学习和借鉴。</p>
<p><a href="https://www.antlr.org/" target="_blank" rel="noopener">ANTLR4的官网</a></p>
<p><a href="https://github.com/antlr" target="_blank" rel="noopener">Github</a></p>
<p>同时ANTLR还有VSCode和Idea的插件，可以可视化的显示语法树，对于开发有很大的帮助。借用<code>ANTLR权威指南</code>作者的一句话：</p>
<blockquote>
<p>为什么不花5天时间编程，来使你25年的生活自动化呢？</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里只涉及Linux平台，Windows会稍有些麻烦，但在官网也都有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/libwget https://www.antlr.org/download/antlr-4.7.2-complete.jarexport CLASSPATH=".:/usr/local/lib/antlr-4.7.2-complete.jar:$CLASSPATH"alias antlr4='java -jar /usr/local/lib/antlr-4.7.2-complete.jar'alias grun='java org.antlr.v4.gui.TestRig'</span><br></pre></td></tr></table></figure>
<p>然后在Terminal输入<code>antlr4</code>就会有版本等信息显示了。</p>
<p>插件则可以直接在VSCode内直接搜索或在Idea的plugin中搜索，也可以从官网直接下载。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>最推荐的学习方式是从官方的语法文件学习：</p>
<p><a href="https://github.com/antlr/grammars-v4" target="_blank" rel="noopener">Github语法Repo</a></p>
<p>仅列出部分比较关键的语法规则</p>
<ul>
<li>小写字母开头的均代表语法规则</li>
<li>大写字母开头的均代表词法规则</li>
<li>词法与语法规则的编写顺序无关紧要</li>
<li>可以在某条产生式后方用<code>#lable</code>的方式添加标签，方便后续对listener或visitor的编写，但只要对其中一个产生式使用了标签，与它同级的所有产生式均需使用标签</li>
<li><code>|*?()</code>等符号的使用均可参考正则表达式</li>
<li>可以使用<code>fragment</code>来对部分需要在不同地方频繁使用但又不需要单独解析的词法进行修饰</li>
</ul>
<h3 id="计算器实例"><a href="#计算器实例" class="headerlink" title="计算器实例"></a>计算器实例</h3><p>以下是来自<code>ANTLR权威指南</code>的构建一个四则运算计算器的.g4文件供参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grammar LabeledExpr; <span class="comment">// rename to distinguish from Expr.g4</span></span><br><span class="line"></span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                # printExpr</span><br><span class="line">    |   ID '=' expr NEWLINE         # assign</span><br><span class="line">    |   NEWLINE                     # blank</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr op=('*'|'/') expr      # MulDiv</span><br><span class="line">    |   expr op=('+'|'-') expr      # AddSub</span><br><span class="line">    |   INT                         # int</span><br><span class="line">    |   ID                          # id</span><br><span class="line">    |   '(' expr ')'                # parens</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">MUL :   <span class="string">'*'</span> ; <span class="comment">// assigns token name to '*' used above in grammar</span></span><br><span class="line">DIV :   <span class="string">'/'</span> ;</span><br><span class="line">ADD :   <span class="string">'+'</span> ;</span><br><span class="line">SUB :   <span class="string">'-'</span> ;</span><br><span class="line">ID  :   [a-zA-Z]+ ;      <span class="comment">// match identifiers</span></span><br><span class="line">INT :   [<span class="number">0</span>-<span class="number">9</span>]+ ;         <span class="comment">// match integers</span></span><br><span class="line">NEWLINE:<span class="string">'\r'</span>? <span class="string">'\n'</span> ;     <span class="comment">// return newlines to parser (is end-statement signal)</span></span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; <span class="comment">// toss out whitespace</span></span><br></pre></td></tr></table></figure>
<p>这里强烈推荐使用Idea搭配ANTLR4插件或者VSCode搭配ANTLR4拓展使用，会有直观的可视化界面。</p>
<p>这是Idea的界面</p>
<p><img src="/2019/01/17/ANTLR4笔记/IdeaWithAntlr.png" alt="ANTLR4plugins"></p>
<p>这是VSCode的界面</p>
<p><img src="/2019/01/17/ANTLR4笔记/VSCodeWithAntlr4.png" alt="ANTLR4VSCode"></p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>为了编写一个语言类应用，我们必须对每个输入的词组或者子词组执行一些适当的操作，即语义动作。最简单的方式就是操作语法分析器自动生成的语法分析树。这样我们就可以回到熟悉的Java领域，构建一个完整的语言类应用。</p>
<p>ANTLR运行库提供两种遍历树的机制。默认情况下，ANTLR使用内建的遍历器访问生成的语法分析树，并为每个遍历可能触发的事件生成一个语法分析树监听器接口(parse-tree listener interface)。一个监听器的方法实际上就是回调函数。除了监听器的方式之外，还有一个访问者模式(visitor pattern)。</p>
<h3 id="语法分析树监听器"><a href="#语法分析树监听器" class="headerlink" title="语法分析树监听器"></a>语法分析树监听器</h3><p>ANTLR运行库提供了ParseTree-Walker类，我们可以自行实现ParseTreeListener接口，填充自己的逻辑代码。</p>
<p>ANTLR为每个语法文件生成一个ParseTreeListener的子类，在该类中，语法中的每条规则都有对应的enter方法和exit方法。例如当遍历器访问到assign规则对应的节点时，它会调用enterAssign()方法，然后将对应的语法分析树节点–AssignContext的实例–当作参数传递给它。在遍历器访问了assign节点的全部子节点之后，它会调用exitAssign()。下面是对语法分析树进行深度优先便利的过程图。</p>
<p><img src="/2019/01/17/ANTLR4笔记/Listener.png" alt="Listener1"></p>
<p>下图是ParseTreeWalker对监听器方法的完整的调用顺序。</p>
<p><img src="/2019/01/17/ANTLR4笔记/ListenerAPI.png" alt="Listener2"></p>
<p>我们可以用监听器的方式来实现之前所说的计算器的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Evaluator</span> <span class="keyword">extends</span> <span class="title">CalcBaseListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Double&gt; vars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ParseTreeProperty&lt;Double&gt; values = <span class="keyword">new</span> ParseTreeProperty&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stmt : ID '=' expr NEWLINE ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitAssign</span><span class="params">(CalcParser.AssignContext ctx)</span> </span>&#123;</span><br><span class="line">        String id = ctx.ID().getText();</span><br><span class="line">        Double val = values.get(ctx.expr());</span><br><span class="line">        vars.put(id, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stmt : expr NEWLINE ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitPrintExpr</span><span class="params">(CalcParser.PrintExprContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(values.get(ctx.expr()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expr : NUMBER ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitLiteral</span><span class="params">(CalcParser.LiteralContext ctx)</span> </span>&#123;</span><br><span class="line">        values.put(ctx, Double.valueOf(ctx.NUMBER().getText()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expr : ID ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitId</span><span class="params">(CalcParser.IdContext ctx)</span> </span>&#123;</span><br><span class="line">        values.put(ctx, vars.containsKey(ctx.ID().getText()) ? vars.get(ctx.ID().getText()) : .<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expr : expr op=('*'|'/') expr ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitMulDiv</span><span class="params">(CalcParser.MulDivContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> lhs = values.get(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">double</span> rhs = values.get(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        values.put(ctx, ctx.op.getType() == CalcParser.MUL ? lhs * rhs : lhs / rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expr : expr op=('+'|'-') expr ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitAddSub</span><span class="params">(CalcParser.AddSubContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> lhs = values.get(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">double</span> rhs = values.get(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        values.put(ctx, ctx.op.getType() == CalcParser.ADD ? lhs + rhs : lhs - rhs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expr : '(' expr ')' ;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitParen</span><span class="params">(CalcParser.ParenContext ctx)</span> </span>&#123;</span><br><span class="line">        values.put(ctx, values.get(ctx.expr()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语法分析树访问器-Visitor"><a href="#语法分析树访问器-Visitor" class="headerlink" title="语法分析树访问器(Visitor)"></a>语法分析树访问器(Visitor)</h3><p>Visitor似乎是在ANTLR4之前使用的比较多，但从ANTLR4以来，官方似乎更偏向于使用Listener了。我们可以在命令行中加入-visitor选项使ANTLR为每一个语法生成访问器接口，语法中的每条规则对应接口中的一个visit方法。下图是常见的访问者模式对我们的语法分析树进行操作的过程。</p>
<p><img src="/2019/01/17/ANTLR4笔记/Visitor.png" alt="Visitor"></p>
<p>Visitor模式会相比较而言更容易上手一些，感兴趣的话可以去了解设计模式相关的内容会更加有帮助一些。</p>
<p>同样是实现计算器，我们可以看看Visitor是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvalVisitor</span> <span class="keyword">extends</span> <span class="title">LabeledExprBaseVisitor</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** "memory" for our calculator; variable/value pairs go here */</span></span><br><span class="line">    Map&lt;String, Integer&gt; memory = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">./</span><br><span class="line">    <span class="comment">/** ID '=' expr NEWLINE */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitAssign</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> </span>&#123;</span><br><span class="line">        String id = ctx.ID().getText();  <span class="comment">// id is left-hand side of '='</span></span><br><span class="line">        <span class="keyword">int</span> value = visit(ctx.expr());   <span class="comment">// compute value of expression on right</span></span><br><span class="line">        memory.put(id, value);           <span class="comment">// store it in our memory</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** expr NEWLINE */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitPrintExpr</span><span class="params">(LabeledExprParser.PrintExprContext ctx)</span> </span>&#123;</span><br><span class="line">        Integer value = visit(ctx.expr()); <span class="comment">// evaluate the expr child</span></span><br><span class="line">        System.out.println(value);         <span class="comment">// print the result</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                          <span class="comment">// return dummy value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** INT */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitInt</span><span class="params">(LabeledExprParser.IntContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ID */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitId</span><span class="params">(LabeledExprParser.IdContext ctx)</span> </span>&#123;</span><br><span class="line">        String id = ctx.ID().getText();</span><br><span class="line">        <span class="keyword">if</span> ( memory.containsKey(id) ) <span class="keyword">return</span> memory.get(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** expr op=('*'|'/') expr */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitMulDiv</span><span class="params">(LabeledExprParser.MulDivContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = visit(ctx.expr(<span class="number">0</span>));  <span class="comment">// get value of left subexpression</span></span><br><span class="line">        <span class="keyword">int</span> right = visit(ctx.expr(<span class="number">1</span>)); <span class="comment">// get value of right subexpression</span></span><br><span class="line">        <span class="keyword">if</span> ( ctx.op.getType() == LabeledExprParser.MUL ) <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">return</span> left / right; <span class="comment">// must be DIV</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** expr op=('+'|'-') expr */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitAddSub</span><span class="params">(LabeledExprParser.AddSubContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = visit(ctx.expr(<span class="number">0</span>));  <span class="comment">// get value of left subexpression</span></span><br><span class="line">        <span class="keyword">int</span> right = visit(ctx.expr(<span class="number">1</span>)); <span class="comment">// get value of right subexpression</span></span><br><span class="line">        <span class="keyword">if</span> ( ctx.op.getType() == LabeledExprParser.ADD ) <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">return</span> left - right; <span class="comment">// must be SUB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** '(' expr ')' */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitParens</span><span class="params">(LabeledExprParser.ParensContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.expr()); <span class="comment">// return child expr's value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p>目前我涉及到的高级特性主要就是将词法符号送入不同的通道。比如在多数情况下，我们的语言中的注释可以直接忽略无视，即不需要对其进行处理，所以我们可以看到如下的语法规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comment : ( &apos;//&apos; ~[\r\n]* | &apos;/*&apos; .*? &apos;*/&apos; ) -&gt; skip ;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>-&gt;skip</code>符号即代表抛弃了Comment所代表的词法符号。但有些时候我们需要这些注释的内容做些事情，这时如果我们将注释作为一个正常的词法符号来看待就会产生一些问题：即注释可以出现在几乎任何地方，这以为着我们需要修改许多文法规则，所以这显然是不好的方法。所以ANTLR4提供了将这些内容送入另一个通道的功能，就类似于广播的不同频段。但是<code>ANTLR权威指南</code>一书中的版本稍显过时，使用它的范例会出现报错，目前找到的合适的语法可参考：</p>
<p><a href="https://github.com/blindpirate/the-definitive-antlr4-reference-code/tree/master/lexmagic" target="_blank" rel="noopener">https://github.com/blindpirate/the-definitive-antlr4-reference-code/tree/master/lexmagic</a></p>
<p>词法和语法是分开在两个文件中的，如何合并到一起我也正在研究。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我主要的目的还是介绍以及推荐ANTLR这一强大的工具，对于接触过编译原理相关知识或是使用过其他编译前端工具的同学，ANTLR非常的容易上手，没接触过的也可以借助这一工具发现一片全新天地。本文主要参考<code>ANTLR权威指南</code>一书以及ANTLR官方文档，也参考了这篇：<a href="https://abcdabcd987.com/notes-on-antlr4/" target="_blank" rel="noopener">Lequn Chen的ANTLR4博文</a>。这篇博文在初期也给予了我极大的帮助。</p>
</div><div class="tags"><a href="/tags/编程语言/">编程语言</a><a href="/tags/Java/">Java</a><a href="/tags/Parser/">Parser</a></div><div class="post-nav"><a class="pre" href="/2019/11/05/一篇自省/">一篇自省</a><a class="next" href="/2018/04/13/对String、StringBuilder以及StringBuffer的简单源码分析/">对String、StringBuilder以及StringBuffer的简单源码分析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'CrabFish';
var disqus_identifier = '2019/01/17/ANTLR4笔记/';
var disqus_title = 'ANTLR4笔记';
var disqus_url = 'https://blog.crabfishhh.com/2019/01/17/ANTLR4笔记/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/next/config.json',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//CrabFish.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.crabfishhh.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术备忘/">技术备忘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日志/">日志</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/课程相关/">课程相关</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/树莓派/" style="font-size: 15px;">树莓派</a> <a href="/tags/算法-OJ/" style="font-size: 15px;">算法 OJ</a> <a href="/tags/思考/" style="font-size: 15px;">思考</a> <a href="/tags/嵌入式/" style="font-size: 15px;">嵌入式</a> <a href="/tags/杂谈/" style="font-size: 15px;">杂谈</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/系统/" style="font-size: 15px;">系统</a> <a href="/tags/建站/" style="font-size: 15px;">建站</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Parser/" style="font-size: 15px;">Parser</a> <a href="/tags/密码学/" style="font-size: 15px;">密码学</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/10/06/上海字节实习小记/">上海字节实习小记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/01/实现一个简单的任务调度器/">实现一个简单的任务调度器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/08/年轻人的第一块树莓派/">年轻人的第一块树莓派</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/Cryptography笔记/">Cryptography笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/18/给网站配置ssl证书/">给网站配置ssl证书</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/一篇自省/">一篇自省</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/17/ANTLR4笔记/">ANTLR4笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/13/对String、StringBuilder以及StringBuffer的简单源码分析/">对String、StringBuilder以及StringBuffer的简单源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/LeetCode部分问题归档/">LeetCode部分问题归档</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/这是一篇通过Hexo生成的博文/">这是一篇通过Hexo生成的博文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//CrabFish.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">CrabFish's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a> <br><a rel="nofollow" target="_blank" href="http://www.beian.miit.gov.cn">浙ICP备17058174号</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>